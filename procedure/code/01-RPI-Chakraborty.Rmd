---
output:
  pdf_document: default
  html_document: default
---
# Rpi-Replication of Social Inequities in the distribution of COVID-19: An intra-categorical analysis of people with disabilities in the U.S.

Joseph Holler, Department of Geography, Middlebury College, Middlebury VT 05753
Drew An-Pham, Department of Geography, Middlebury College, Middlebury VT 05753 
Derrick Burt, Department of Geography, Middlebury College, Middlebury VT 05753
Junyi Zhou, Department of Geography, Middlebury College, Middlebury VT 05753 
Peter Kedron, School of Geographical Sciences and Urban Planning, Arizona State University, Tempe AZ 85281 

Version 0.0 | Created Jul 10, 2022 | Last Updated Jul 10, 2022

## Abstract
Chakraborty (2021) investigates the relationships between COVID-19 rates and demographic characteristics of people with disabilities by county in the lower 48 states. The study aims to examine public concern that persons with disabilities (PwDs) face disproportionate challenges due to COVID-19. To investigate this, Chakraborty examines the statistical relationship between confirmed county-level COVID-19 case rates and county-level socio-demographic and disability variables. Specifically, Chakraborty tests county-level bivariate correlations between COVID-19 incidence against the percentage of disability and socio-demographic category, with a separate hypothesis and model for each subcategory within disability, race, ethnicity, age, and biological sex. To control for differences between states and geographic clusters of COVID-19 outbreaks, Chakraborty uses five generalized estimating equation (GEE) models to predict the relationship and significance between COVID-19 incidence and disability subgroups within each socio-demographic category while considering inter-county spatial clusters. Chakraborty (2021) finds significant positive relationships between COVID-19 rates and socially vulnerable demographic categories of race, ethnicity, poverty, age, and biological sex.

This replication study is motivated by expanding the potential impact of Chakraborty's study for policy, research, and teaching purposes. In this replication study, we attempt to follow the logic of Chakraborty's study but use new data and alternative methodology to examine temporal changes and test for different hypotheses. We will analyze the relationship between COVID-19 death rate and socio-demographic and disability characteristics, calculate the summary statistics, and apply a weighted Spearman rho's correlation coefficient on measuring the relationship. We also plan to conceptualize geographic clusters in the GEE models using the state in which the county falls into and whether this county is urban or rural. In addition, we will calculate the hot spot and cold spot based on the excess death rate using the Getis-Ord Spatial Cluster statistics and examine disability status.  

Through measuring the relationship between death rate during COVID-19 and socio-demographic and disability characteristics, this replication study can provide important information for public health policy-making and resource allocation. It also increases the significance of Chakraborty's study by extending and modifying it with more alternative data and methods, which allows students of geography and spatial epidemiology to learn from the study design and methods.

The replication study data and code will be made available in a GitHub repository to the greatest extent that licensing and file sizes permit. The repository will be made public at [github.com/HEGSRR/RPl-Chakraborty-2022](). 

Chakraborty, J. 2021. Social inequities in the distribution of COVID-19: An intra-categorical analysis of people with disabilities in the U.S. Disability and Health Journal 14:1-5. DOI:[10.1016/j.dhjo.2020.101007]()

### Keywords
COVID-19; Disability; Intersectionality; Race/ethnicity; Poverty; Replicability


## Study Design

### Original study design
The original study is **observational**, with the **exploratory** objective of determining "whether COVID-19 incidence is significantly greater in counties containing higher percentages of socio-demographically disadvantaged [people with disabilities], based on their race, ethnicity, poverty status, age, and biological sex" (Chakraborty 2021). This exploratory objective is broken down into five implicit hypotheses that each of the demographic characteristics of people with disabilities is associated with higher COVID-19 incidence rates.

The **spatial extent** of the study are the 49 contiguous states in the U.S.
The **spatial scale** of the analysis is at the county level.
Both COVID-19 incidence rates and demographic variables are all measured at the county level.
The **temporal extent** of the COVID-19 data ranges from 1/22/2020 (when John Hopkins began collecting the data) to 8/1/2020 (when the data was retrieved for the original study).
The data on disability and sociodemographic characteristics come from the U.S. Census American Community Survey (ACS) five-year estimates for 2018 (2014-2018).

The study was originally conducted using SaTScan software (unspecified version) to implement the spatial scan statistic.
Other software are not specified in the publication; however data files and communication with the author show that spatial analysis and mapping was conducted in ArcGIS and statistics were calculated in SPSS.


### Replication study design
This replication follows the logic of the original study, but is implemented with new data and different methods. In the first part of the replication analysis, we plan to create the maps of county level distribution COVID-19 death rate and disability rate. In the second part, we plan to calculate summary statistics and bivariate weighted correlation for disability characteristics and COVID-19 death rate. In the last part, we plan to implement the generalized estimating equations using five models, including one for each dimension of socio-demographics: race, ethnicity, poverty status, age, and biological sex. We re-conceptualize geographic clusters in the GEE models using the state in which the county falls into and whether this county is urban or rural. We also implemented the Getis-Ord statistics that calculate COVID-19 hotspots and coldspots.  

The **spatial extent** of the study are the 49 contiguous states in the U.S.
The **spatial scale** of the analysis is at the county level.
Both COVID-19 death rates and demographic variables are all measured at the county level.
The **temporal extent** of the COVID-19 data ranges from 1/22/2020 (when John Hopkins began collecting the data) to 7/2/2022 (when we retreived the data for analysis). 
The data on disability and sociodemographic characteristics come from the U.S. Census American Community Survey (ACS) five-year estimates for 2020 (2016-2020).
The data on county classification (urban or rural) come from the USDA Economic Research Service Rural-Urban continnum code for 2013. 

The replication study is conducted entirely in R. We uses the `geepack` to implement the generalized estimating equations, the `wCorr` to implemented weighted Spearman Rho's correlation coefficient, `tidycensus` to obtain socio-demographic and poverty data, and the `sf` package for spatial analysis. The mapping is done using the `tmap` package and all other analysis are done using `tidyverse` package. 

### Load Required Packages

```{r setup, message = FALSE, include = FALSE}

# list of required packages
packages <- c(
  "tidycensus", "tidyverse", "downloader", "sf", "classInt", "readr",
  "here", "s2", "pastecs", "tmap", "readxl", "svDialogs",
  "geepack", "wCorr"
)

# load and install required packages
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE, quietly = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

# save the R processing environment
writeLines(
  capture.output(sessionInfo()),
  here("procedure", "environment", "r_environment.txt")
)

```


## Query American Communtity Survey Data

This will require an API key for the census, which can be acquired easily here: [api.census.gov/data/key_signup.html](https://api.census.gov/data/key_signup.html)
This query can take some time to run...

```{r Load ACS Data, message = FALSE, eval = FALSE}

# get API Key
# we could store this in the raw/private or scratch folder and load if the
# researcher has already entered it once
census_api_key(dlgInput(
  "Enter a Census API Key",
  Sys.getenv("CENSUS_API_KEY")
)$res,
overwrite = TRUE
)

# Query disability demographic data with geographic boundaries
acs_2020 <- get_acs(
  geography = "county",
  table = "S1810",
  year = 2020,
  output = "wide",
  cache_table = TRUE,
  geometry = TRUE,
  keep_geo_vars = TRUE
)

# Query poverty and disability data
pov_2020 <- get_acs(
  geography = "county",
  table = "C18130",
  year = 2020,
  output = "wide",
  cache_table = TRUE
)

```

### Filtering and joining the ACS data
This accomplishes the step 1 and 3 of the workflow diagram

```{r filter and join acs data, message = FALSE, eval = FALSE}

# Remove Alaska, Hawaii & Puerto Rico
acs_2020 <- filter(acs_2020, !STATEFP %in% c("02", "15", "72"))

# Join poverty data to disability data
acs_2020 <- left_join(acs_2020, pov_2020, by = "GEOID")

```


## Save raw data

Optionally, you may save the raw data to data/raw/public/acs.gpkg

```{r save ACS data, message = F, eval = FALSE}

# Save downloaded acs data to acs.gpkg
write_sf(acs_2020, here("data", "raw", "public", "acs2020.gpkg"))

```

## Load raw data

Optionally, you may load the raw data and begin processing here

```{r load ACS data, message = F}

acs_2020 <- read_sf(here("data", "raw", "public", "acs2020.gpkg"))

```

## Preprocess ACS data
This accomplishes the step 4 the workflow diagram

Calculate percentages for each sub-category of disability and remove raw census data from the data frame

```{r Preprocess ACS data, message = FALSE}

# calculate percentages
acs_derived <- mutate(acs_2020,
  dis_pct = S1810_C02_001E / S1810_C01_001E * 100,
  white_pct = S1810_C02_004E / S1810_C01_001E * 100,
  black_pct = S1810_C02_005E / S1810_C01_001E * 100,
  native_pct = S1810_C02_006E / S1810_C01_001E * 100,
  asian_pct = S1810_C02_007E / S1810_C01_001E * 100,
  other_pct =
    (S1810_C02_008E + S1810_C02_009E + S1810_C02_010E) / S1810_C01_001E * 100,
  non_hisp_white_pct = S1810_C02_011E / S1810_C01_001E * 100,
  hisp_pct = S1810_C02_012E / S1810_C01_001E * 100,
  non_hisp_non_white_pct =
    (S1810_C02_001E - S1810_C02_012E - S1810_C02_011E) / S1810_C01_001E * 100,
  bpov_pct = (C18130_004E + C18130_011E + C18130_018E) / C18130_001E * 100,
  apov_pct = (C18130_005E + C18130_012E + C18130_019E) / C18130_001E * 100,
  pct_5_17 = S1810_C02_014E / S1810_C01_001E * 100,
  pct_18_34 = S1810_C02_015E / S1810_C01_001E * 100,
  pct_35_64 = S1810_C02_016E / S1810_C01_001E * 100,
  pct_65_74 = S1810_C02_017E / S1810_C01_001E * 100,
  pct_75 = S1810_C02_018E / S1810_C01_001E * 100,
  male_pct = S1810_C02_002E / S1810_C01_001E * 100,
  female_pct = S1810_C02_003E / S1810_C01_001E * 100
)

# select only relevant geographic identifiers and derived percentages
# and transform to USA Contiguous Albers Equal Area Conic projection
acs_derived <- acs_derived %>%
  select(
    geoid = GEOID,
    statefp = STATEFP,
    county = NAME.x,
    county_st = NAME,
    contains("pct")
  ) %>%
  st_transform(5070)

```

## Load COVID-19 data
This accomplishes the step 2 of the workflow diagram

This data has been provided directly with the research compendium because it is no longer available online in the state in which it was downloaded on August 1, 2020.
The data was provided by the original author, Jayajit Chakraborty.

```{r load covid data}

death <- readRDS(here("data","raw","public","death.RDS"))

```

### Join COVID data to ACS data
This accomplishes the step 5 of the workflow diagram

```{r join data}

# select only relevant variables and typecast geographic identifiers
# join covid data to demographic data
death_table <- select(death, county_name, state_fips, county_fips, county_code, excess_deaths_2020, excess_death_rate_2020)
acs_derived$geoid <- as.numeric(acs_derived$geoid)
acs_covid <- left_join(acs_derived, death_table, by = c("geoid" = "county_code")) 

```


## Missing Data

There are two counties with missing data on excess death. Below, we replace the missing data with zeros. 

```{r missing data} 

# now replace county with missing data on excess death
# county with missing data
filter(acs_covid, is.na(excess_death_rate_2020))

# replace NA with 0 for missing data
acs_covid[is.na(acs_covid$excess_death_rate_2020), ]$excess_death_rate_2020 <- 0

```

## Map Covid Rates

```{r get state geometry}

state <- get_acs(geography = "state", 
                 variables = c("Total Population" = "B01001_001"),
                 year = 2018, 
                 geometry = TRUE,
                 keep_geo_vars = TRUE)

state <- filter(state, !STATEFP %in% c("02", "15", "72"))

```


```{r map covid rates}

tm_death_rate <- tm_shape(acs_covid) +
  tm_polygons("excess_death_rate_2020",
    title = "COVID-19 Excess Deaths Rate 2020",
    style = "quantile",
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr"
  ) +
  tm_shape(state) +
  tm_borders("grey", lwd = .8) +
  tmap_options(check.and.fix = TRUE)

tm_death_rate

tmap_save(tm_death_rate, here("results", "figures", "death_rates.png"))
```

## Map Disability Rates

```{r map disability rates}

tm_disability_rate <- tm_shape(acs_covid) +
  tm_polygons("dis_pct",
    title = "Percent with Disability",
    style = "quantile",
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr"
  ) +
  tm_shape(state) +
  tm_borders("grey", lwd = .8) +
  tmap_options(check.and.fix = TRUE)


tm_disability_rate

tmap_save(tm_disability_rate, here("results", "figures", "disability_rates.png"))

```



## Descriptive Statistics

```{r descriptive statistics}

acs_covid_stats <- acs_covid %>%
  st_drop_geometry() %>%
  select(where(is.numeric)) %>%
  select(-geoid,-state_fips) %>% 
  stat.desc(norm = TRUE) %>%
  round(2) %>%
  t() %>%
  as.data.frame() %>%
  select(min, max, mean, SD = std.dev, ShapiroWilk = normtest.W, p = normtest.p)

acs_covid_stats

```

## Calculate Spearman's Rho Correlation Coefficients

Try a non-parametric correlation test because variables do not have
normal distributions (see Shapiro-Wilk test results above).
The direction of several of the variables changes with the non-parametric
test.

```{r spearmans correlation}

df <- sum(!is.na(acs_covid$dis_pct)) - 2

spearmans_rho <- acs_covid %>%
  select(where(is.numeric)) %>%
  select(-geoid,-state_fips, -excess_deaths_2020) %>% 
  st_drop_geometry() %>%
  cor(method = "spearman", use = "pairwise.complete.obs") %>%
  as.data.frame() %>%
  select(rho = excess_death_rate_2020) %>%
  mutate(
    t = abs(rho) / sqrt((1 - rho^2) / (df)),
    p = pt(t, df, lower.tail = FALSE)
  ) %>%
  round(3) %>%
  rownames_to_column("variable") %>%
  filter(variable != "excess_death_rate_2020")

spearmans_rho

```

```{r}
install.packages('wCorr')
library('wCorr')
```


```{r}
pop_2020 <- get_acs(
  geography = "county",
  table = "B01003",
  year = 2020,
  output = "wide",
  cache_table = TRUE
)


pop_2020 <- pop_2020 %>% 
  select(
    geoid = GEOID,
    total_pop = B01003_001E) 


pop_2020$geoid <- as.numeric(pop_2020$geoid)

acs_covid <- left_join(acs_covid, pop_2020, by = "geoid")
```



```{r}

temp <- acs_covid %>%
  st_drop_geometry()

temp <- left_join(temp, pop_2020, by = "geoid")

```


```{r}

temp <- temp %>%  
  filter(!is.na(excess_death_rate_2020)) %>%
  arrange()


weightedCorr(y = temp$excess_death_rate_2020, x = temp$dis_pct, weights = temp$total_pop, method = "Spearman")
weightedCorr(y = temp$excess_death_rate_2020, x = temp$dis_pct, weights = temp$total_pop, method = "Pearson")


```


```{r}

temp <- temp %>% 
  select(where(is.numeric)) %>%
  select(-geoid,-state_fips, -excess_deaths_2020) %>% 

temp <- temp %>% 
  select(-RUCC_2013, -code)


to_do_list <- combn(names(temp),2,simplify = FALSE)

res <- purrr::map_dfr(to_do_list,
               ~tibble(var_row = .[[1]],
                       var_col = .[[2]],
                       wCorr = wCorr::weightedCorr(x = temp[[.[[1]]]],
                                                   y= temp[[.[[2]]]],
                                                   weights = temp$total_pop,
                                                   method = "Spearman"))) 

res <- res[res$var_col == "excess_death_rate_2020", ]



```


```{r}

df <- sum(!is.na(temp$dis_pct)) - 2

spearman_wcorr <- res %>% 
 select(wCorr) %>% 
 mutate(
    t = abs(wCorr) / sqrt((1 - wCorr^2) / (df)),
    p = pt(t, df, lower.tail = FALSE)
  ) %>%
  round(3)
   

```


```{r}

res <- res %>% 
  mutate(wCorr = round(wCorr,3))

spearman_wcorr %>% 
  left_join(res, by = "wCorr") %>% 
  select(-var_col) %>% 
  select(var_row, everything())
  

```






# Urban rural classification of counties 


```{r load classification data}

urbanrural <- read_excel(here("data","raw","public","ruralurbancodes2013.xls"))

```


```{r further classify counties into three categories}

urbanrural <- urbanrural %>% 
  select(-Description) %>% 
  mutate(code = case_when(RUCC_2013 == 1 | RUCC_2013 == 2 | RUCC_2013 == 3 ~ 1,
                          RUCC_2013 == 4 | RUCC_2013 == 5 | RUCC_2013 == 6 | RUCC_2013 == 7 ~ 2,
                          RUCC_2013 == 8 | RUCC_2013 == 9 ~3)) %>% 
  mutate(code_exp = case_when(RUCC_2013 == 1 | RUCC_2013 == 2 | RUCC_2013 == 3 ~ "Metropolitan",
                          RUCC_2013 == 4 | RUCC_2013 == 5 | RUCC_2013 == 6 | RUCC_2013 == 7 ~ "Micropolitan",
                          RUCC_2013 == 8 | RUCC_2013 == 9 ~"Noncore"))

```


```{r join urban rural classification to demographic variables}


urbanrural$FIPS <- as.numeric(urbanrural$FIPS)

acs_covid <- left_join(acs_covid, urbanrural, by = c("geoid" = "FIPS")) 

acs_covid <- acs_covid %>% 
  select(-c(State, County_Name, Population_2010))

# replace missing data
filter(acs_covid, is.na(code))

acs_covid[is.na(acs_covid$code), ]$code <- 3
acs_covid[is.na(acs_covid$code_exp), ]$code_exp <- "Noncore"


```


## Map Urban Rural Counties



```{r map original relative risk scores}

tm_urbanrural <- tm_shape(acs_covid) +
  tm_polygons("code_exp",
    title = "County Classification",
    border.alpha = .5,
    lwd = 0.2,
    palette = "Pastel1",
    style = "cat"
  ) + 
  tm_shape(state) +
  tm_borders("grey", lwd = .8) +
  tmap_options(check.and.fix = TRUE)

tm_urbanrural

tmap_save(tm_urbanrural, here("results", "figures", "urbanrural.png"))

```

## Preprocess data for GEE modelling
This accomplishes the step 9 and 10 of the workflow diagram

```{r preprocess data for GEE model }

# Create unique State - Urbanrural IDs by combining state code and rr_class
# Sort by the cluster id's (a requirement of the gee function)
gee_data <- acs_covid %>%
  filter(!is.na(excess_death_rate_2020)) %>%
  mutate(id = as.integer(statefp) * 10 + code) %>%
  arrange(id)


gee_data <- gee_data %>%
  mutate(
    z_bpov_pct = scale(bpov_pct),
    z_apov_pct = scale(apov_pct),
    z_white_pct = scale(white_pct),
    z_black_pct = scale(black_pct),
    z_native_pct = scale(native_pct),
    z_asian_pct = scale(asian_pct),
    z_other_pct = scale(other_pct),
    z_non_hisp_white_pct = scale(non_hisp_white_pct),
    z_hisp_pct = scale(hisp_pct),
    z_non_hisp_non_white_pct = scale(non_hisp_non_white_pct),
    z_pct_5_17 = scale(pct_5_17),
    z_pct_18_34 = scale(pct_18_34),
    z_pct_35_64 = scale(pct_35_64),
    z_pct_65_74 = scale(pct_65_74),
    z_pct_75 = scale(pct_75),
    z_male_pct = scale(male_pct),
    z_female_pct = scale(female_pct)
  )


```

## Save preprocessed GEE data inputs

Optionally, you may save the preprocessed to `data/raw/public/gee_data.gpkg`

```{r save preprocessed COVID cluster data, eval = FALSE}

write_sf(gee_data, here("data", "derived", "public", "gee_data.gpkg"))

```

## Load preprocessed GEE input data

Optionally, you may load the preprocessed data from `data/raw/public/gee_data.gpkg`

```{r load preprocessed COVID cluster data, eval = FALSE}

gee_data <- read_sf(here("data", "derived", "public", "gee_data.gpkg"))

```

# Report number of unique clusters and histogram of counties per cluster

```{r report unique clusters}

cluster_summary <- gee_data %>%
  st_drop_geometry() %>%
  count(id)
cat(length(cluster_summary$n), "unique clusters\n")
summary(cluster_summary$n)
hist(cluster_summary$n) # improve labels for this graph

```

## GEE Models
This accomplishes the step 11 of the workflow diagram

Generalized Estimating Equation parameters:

"The **‘exchangeable’ correlation matrix** was selected for the results reported here, since this speci-fication yielded the best statistical fit based on the QIC (quasi- likelihood under the independence) model criterion."
(Chakraborty 2021, Methods paragraph 5)

"The **gamma distribution** with **logarithmic link function** was chosen for all GEEs since this model specification provided the lowest QIC value."
(Chakraborty 2021, Methods paragraph 5)

Useful Reference:
https://data.library.virginia.edu/getting-started-with-generalized-estimating-equations/


```{r}
ggplot(acs_covid, aes(x=excess_death_rate_2020)) + geom_histogram()
```


```{r gee models}

# it would be smarter to iterate over a list of models and their parameters
# currently stuck on how to add GLM model results to a cell of a dataframe
# not the only one:
# https://www.reddit.com/r/rstats/comments/p50mce/coding_a_loop_for_many_linear_regressions/

race_gee <- geeglm(
  excess_death_rate_2020 ~ z_white_pct + z_black_pct + z_native_pct + z_asian_pct + z_other_pct,
  data = gee_data, # data frame
  id = id, # cluster IDs
  family = gaussian(link = "identity"),
  corstr = "exchangeable"
)

# Wald and P calculated in summary only;
# coef() extracts coefficients table from the summary, same as $coefficients

ethnicity_gee <- geeglm(
  excess_death_rate_2020 ~ z_non_hisp_white_pct + z_hisp_pct + z_non_hisp_non_white_pct,
  data = gee_data,
  id = id,
  family = gaussian(link = "identity"),
  corstr = "exchangeable"
)

pov_gee <- geeglm(
  excess_death_rate_2020 ~ z_bpov_pct + z_apov_pct,
  data = gee_data,
  id = id,
  family = gaussian(link = "identity"),
  corstr = "exchangeable",
)

age_gee <- geeglm(
  excess_death_rate_2020 ~ z_pct_5_17 + z_pct_18_34 + z_pct_35_64 + z_pct_65_74 + z_pct_75,
  data = gee_data,
  id = id,
  family = gaussian(link = "identity"),
  corstr = "exchangeable"
)

sex_gee <- geeglm(
  excess_death_rate_2020 ~ z_male_pct + z_female_pct,
  data = gee_data,
  id = id,
  family = gaussian(link = "identity"),
  corstr = "exchangeable"
)

# summarize model coefficients
coefficient_results <- rbind(
  coef(summary(race_gee)),
  coef(summary(ethnicity_gee)),
  coef(summary(pov_gee)),
  coef(summary(age_gee)),
  coef(summary(sex_gee))
) %>%
  round(3)

# disambiguate intercepts
coefrows <- rownames(coefficient_results)
coefrows[1] <- "Race Intercept"
coefrows[7] <- "Ethnicity Intercept"
coefrows[11] <- "Poverty Status Intercept"
coefrows[14] <- "Age Intercept"
coefrows[20] <- "Biological Sex Intercept"
rownames(coefficient_results) <- coefrows
coefficient_results

# summarize model QICs
QIC_results <- data.frame(
  race = QIC(race_gee),
  ethnicity = QIC(ethnicity_gee),
  poverty_status = QIC(pov_gee),
  age = QIC(age_gee),
  biological_sex = QIC(sex_gee)
) %>%
  round(3) %>%
  t() %>%
  as.data.frame() %>%
  select(QIC)
QIC_results

```


